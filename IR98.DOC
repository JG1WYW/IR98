
    IR98 --- PC98 用 割り込みハンドラ設定モデュール (C) 1993, 1994 by tar

□ 用途

　IR98 は PC98 専用の割り込みハンドラ設定モデュールです. PC98 に限定する理由は
ハードウェア割り込みが機種依存だからです. IR98 は 'I'nter'R'upt '98' の略です.

　IR98 を使うと FTL MODULA-2 でレジデントユーティリティが簡単に記述できます.
そうでなくとも Vsync などの定期的な割り込みが必要になるシーンは山ほどありま
すので, なにかと便利に利用することができます.

　IR98 を使う実行ファイルは必ずラージモデルでリンクする必要があります.

□ 用語の定義

　このような説明文で用語の定義が曖昧では混乱しますので, 次のように定義して
おきます.

    レジデントユーティリティ, TSR:
        常駐可能なプログラム, しばしば常駐しているプログラム.
    
    レジデントユーティリティを解放する:
        常駐を解除し, 領域を解放する.
    
    ロードプログラム:
        シェルから直接呼び出された, いわゆる常駐ではないプログラム
    
    割り込みタイプ:
        int 28h や int 0ah という場合の '28h' や '0ah' という番号のこと.
    
    割り込みハンドラ:
        割り込みが発生した時に呼び出されるルーチン.
    
    割り込み手続き:
        割り込みハンドラから呼ばれる MODULA-2 レベルの割り込みハンドラ.
    
    割り込みベクタアドレス, IVA:
        割り込みハンドラへのポインタが格納されるアドレス.
    
    (割り込みを) フックする, リンクする:
        割り込みが発生すると自分に制御が移るが, それまでに設定されていた
        割り込みハンドラも呼び出す.
    
    割り込みハンドラを設定する:
        ある割り込みベクタアドレスの内容を書き換えて, 新しい割り込みハンドラを
        設定する. そのハンドラはその割り込みをフックすることになる.
    
    フックを解除する:
        割り込みベクタアドレスの内容を元どおりにする.
    
    割り出し:
        ソフトウェア割り込みを発生させること. 慶應大学では普及した呼び方らしい.
    
    再入:
        再帰呼びだしの同義語. 〜可能/不可能を論ずる.
    
    解除する, 復帰する:
        元どおりにする.
    
    (MODULA-2 で) 普通に (記述できる):
        アセンブラを必要としない, また, 静的データ, スタックへのアクセスに
        特別な配慮が要らないの意. しかし DOS ファンクションが自由に出来ると
        いう意味ではない.

　なお, この定義はあくまで混乱しないための, このドキュメントの中でのみ通用する,
一時的な定義とします.

□ 使い方

　まず IR98 から次の算体をインポートする:

    LinkVsync       Vsync 割り込みハンドラを設定する手続き
    UnlinkVsync     Vsync 割り込みハンドラを復帰する手続き
    VTYPE           Vsync 割り込みタイプ
    NewVsync        新しい Vsync IVA の内容
    VsyncIVA        現在の Vsync IVA の内容

    LinkBG          バックグラウンド割り込みハンドラを設定する手続き
    UnlinkBG        バックグラウンド割り込みハンドラを復帰する手続き
    BTYPE           バックグラウンド割り込みタイプ
    NewBG           新しいバックグラウンド IVA の内容
    BGIVA           現在のバックグラウンド IVA の内容

    EXIST           存在確認完了識別子
    LinkExist       存在確認割り込みハンドラを設定する手続き
    UnlinkExist     存在確認割り込みハンドラを復帰する手続き
    ETYPE           存在確認割り込みタイプ (int 1ah: プリンタ BIOS)
    NewExist        新しい存在確認 IVA の内容
    ExistIVA        現在の存在確認 IVA の内容

    IPROC           手続き型 PROCEDURE( CARDINAL ): CARDINAL
    Icall           制御渡し手続き
    Free            領域解放手続き
    GetINDOS        INDOS フラグアドレス取得手続き
    GetMCB          MCB アドレス取得手続

◎ PROCEDURE LinkVsync( proc: PROC; soff: CARDINAL );

　Vsync で割り込む手続きを設定します.

　Vsync とは CRT の垂直同期信号割り込みのことで, 約 1/60 秒に 1 回, 割り込みが
発生します. これにみんながぶら下がっていますので, 割り込みルーチン内ではフラグ
の設定などの軽い処理だけしか許されません.

　proc は引数のない手続きです. 引数のない手続きの型は言語仕様であらかじめ標準
識別子 PROC と定義されています.

　proc 手続きはなるべく定義モデュールで外にくくりだして下さい. というのも, 定義
モデュールで定義しない手続きは自動的に NEAR CALL となるため, FAR CALL で呼び出
すためには余計なコードが必要となってしまい, 普通の FAR CALL より逆に効率が落ち
るからです. ただし, この付加コードはコンパイラが作りますので, 定義モデュールに
くくり出さなかった場合でも, 特にユーザーが心配することはありません.

　Vsync が発生すると proc が呼ばれることになります.

　soff は proc の用いるスタックのオフセットです. セグメントは 1 つの実行
ファイルで共有されているので, 指定する必要はありません. オフセットは次のように
用いられます. LinkVsync を発行した時点のスタックポインタからオフセットだけ
深いポインタから (すなわち SS: SP-soff から) proc がスタックを使用します.

　繰り返しになりますが, proc は普通に記述される手続きです. LinkVsync への
引数が正しければ, 局所変数にも大域変数にも自由にアクセスできます. なぜならば
各手続きにおいて正しい DS の値はスタックのセグメントテーブルから巧くロード
されるからです.

　Link 手続きは 1 つのロードプログラムにつき各々 1 個づつの割り込み手続きしか
設定できません. 2 個以上を設定しないで下さい. たとえば Vsync に手続き A と B
をリンクするということは出来ません.

　Link 手続きで設定する proc の中では, 自分がフックしている割り込みタイプ
を割り出さないでください. 手続き自体が再入可能でも, フック中の手続き
には再入されないようになっています. つまり, その割り込みタイプの割り込みが
掛かると, 即座にリンクされた残りのハンドラへ制御が移るということです.

　Link 手続きを発行すると, 対応する NewExist, NewVsync, NewBG に新しい IVA の
内容が格納されます.

□ LinkVsync を使う上での注意

　LinkVsync 手続きで設定された手続きは Vsync 割り込みをフックしますが, しかし
Vsync マネージャーとしての正当な機能は持ちません. Vsync 割り込みを発生させるた
めには適切な時期に定期的にポート 64h に (何か) 出力しなければならないのですが,
これ行いません. 単にフックするだけです.

　上記の動作は, IR98 モデュールに書いてしまうと, IR98 を使った回数だけマネー
ジャーが増殖してしまうため, わざとこういう仕様にしました. たぶん, 誰かが先に
常駐してサービスしている筈なので, 心配ないと思います. もし, マネージャーが常駐
していなければ, 何でもよいので Vsync 割り込みをサービスする行儀のよさそうな
レジデントユーティリティを 1 個, 余計に常駐させてください.

　Vsync を使うプリンタスプーラなんかが良いと思います. あれば便利です. でも,
普通は誰かが常駐しているはずです.

◎ PROCEDURE UnlinkVsync;

　Vsync 割り込みのフックを解除します. もし LinkVsync を呼び出している場合で
かつ, レジデントユーティリティを作らない場合は絶対に呼び出す必要があります.
そうしないと, Vsync の発生で暴走することになります. またレジデントユーティリ
ティを解放する場合も, 解放の前に必ず実行する必要があります.

◎ PROCEDURE LinkBG( proc: PROC; soff: CARDINAL );

　DOS のバックグラウンド割り込み (int 28h) で割り込む手続きを設定します.

　DOS のバックグラウンド割り込みとは, キー入力待ちなどで DOS が親切に掛けて
くれる, レジデントユーティリティのための割り込みです.

　proc, soff の設定は LinkVsync と同様です.

　int 28h が発生すると proc が呼ばれることになります.

◎ PROCEDURE UnlinkBG;

　バックグラウンド割り込みのフックを解除します. もし LinkBG を呼び出している
場合で, かつ, レジデントユーティリティを作らない場合は絶対に呼び出す必要があ
ります. そうしないと, int 28h の発生で暴走することになります. またレジデント
ユーティリティを解放する場合も, 解放の前に必ず実行する必要があります.

◎ PROCEDURE LinkExist( id: CARDINAL; proc: IPROC; soff: CARDINAL );

　存在確認割り込みハンドラを設定します.

　存在確認とは, レジデントユーティリティが重複して常駐しないように, すでに
常駐しているかどうか確認するための割り込みです. 実際には PC98 の 1ah, すなわち
プリンタ BIOS をフックして, この用途に使います.

  !!! Vsync, BG と違って, 設定した proc は勝手に割り込んで実行されません !!!

　ユーザーは「試しに ETYPE を割り出してみて, その結果によって, レジデントユー
ティリティが存在しているかいないか」を確認します.

         !!! ETYPE の割り出しで実行されるのは proc ではありません !!!

　ETYPE の割り出しで実行されるルーチンはコード内部に隠されたハンドラです.

　さて, id が確認のための識別子になります. ソフトごとに好きな値を決めます.
id は 上位 8bit がプリンタ BIOS の機能番号に重複しない 16bit の値です.
ダメな値は AH = 10h, 11h, 12h, 30h などです. もしフック後の挙動がおかしい
場合は id を変えて試してください.

　proc は IPROC 型の関数です. IPROC は次のように定義されています:

    TYPE IPROC = PROCEDURE( CARDINAL ): CARDINAL;

　proc, soff の設定方法は Vsync, BG と同様です. しかし proc の意味が違います.

　Vsync, BG と違って, 設定した proc は勝手に割り込んで実行される類の手続きでは
ありませんし, また ETYPE を割り出して実行される類の手続きでもありません.

　これから proc の扱い方を説明します. とりあえず頭の中でレジデントユーティリ
ティの動作を連想してください.

　みなさんはまず次の算体をインポートします:

    FROM MSDOS IMPORT Int, Registers;
    FROM IR98 IMPORT ETYPE, EXIST;

　さて, このレジデントユーティリティの id は 9876h と決めたことにします.
これから存在確認をするので id を AX にセットして通常の割り込みと同様に,
次のように ETYPE を割り出します:

    VAR
        regs: Registers;

    ...

    regs.AX := 9876h;        (* id は 9876h と決めた *)
    Int( ETYPE, regs );      (* ETYPE を割り出す *)
    IF regs.AX = EXIST THEN
        (* 常駐している *)
    ELSE
        (* 常駐していない *)
    END

　つまり, もし既に常駐しているならば, 割り込み後に AX レジスタに EXIST が
セットされて帰ってくるのです. これで存在確認を行うことができます.

　さて, proc はどうなったのでしょうか. これは既に常駐していた場合に意味を
持ちます. というのも, 常駐しているのならば, 何らかの交信, データのやり取りを
やりたくなるのが世の常で, どこかしら常駐プログラムに制御を渡したくなります.

　そこで proc に制御を渡すことを考えます. AX レジスタに id が帰ってきたように
proc のコードセグメント, オフセット, スタックセグメント, スタックポインタも,
次のようにセットされて帰ってきます:

                  ( proc の )
    regs.ES     コードセグメント
    regs.BX     コードオフセット
    regs.DS     スタックセグメント
    regs.DX     スタックポインタ

　これらの値はいわば「エントリーポイント」で, この後もそう呼びます.

◎ PROCEDURE UnlinkExit;

　存在確認割り込みのフックを解除します. LinkExist を呼び出した場合で, かつ,
レジデントユーティリティを作らない場合は絶対に呼び出す必要があります.
またレジデントユーティリティを解放する場合も, 解放の前に必ず実行する必要が
あります.

◎ PROCEDURE Icall( VAR r: Registers; i:CARDINAL ): CARDINAL;

　Icall はエントリーポイントへ制御を移す関数です. いま, LinkExist に渡す関数を
Selector として, 次のように定義します. 手続きの型は IPROC と決められています:

    PROCEDURE Selector( i: CARDINAL ): CARDINAL;

　Selector という名前を付けたのは, 引数の値によって各種の処理に分岐するため
です. 具体的には i の値によって異なる動作をするようにして, 例えば PSP を返し
たり, Unlink 手続きを呼び出したり, あるいは常駐プログラム中のデータにアクセス
して, 値を返したりするのです. Selector 手続きの中からは, (もちろんそれはレジデ
ントユーティリティの中なのですが), 自由にコードを渡り歩くことができます.

　でも混乱しないでください. 直接 Selector 関数を呼べば, それはレジデントユー
ティリティ側の Selector ではなく, ロードプログラム側の Selector に制御が移り
ます. 逆にIcall 関数からエントリーポイント (すなわち Selector) に制御を移せば,
それはレジデントユーティリティ側の Selector に到達するのです.

　さて, Selector の具体的な例を示しましょう:

FROM LOADER IMPORT
    ProgPrefixAddress;
FROM MSDOS IMPORT
    SEGMENT;
FROM IntStub IMPORT
    DisableInterrupts, EnableInterrupts;
FROM IR98 IMPORT
    UnlinkBG, UnlinkExist;

VAR
    OldCopy: ADDRESS;                           (* 起動時に待避されている *)
    CopyIVA[ 0: CTYPE * 4 ]: ADDRESS;           (* Copy キー IVA *)

PROCEDURE Selector( i: CARDINAL ): CARDINAL;
BEGIN
    CASE i OF (* i の値に従って, レジデントユーティリティで好きな処理を行う *)
    0:
        UnlinkBG;               (* IVA を復帰した後, PSP のセグメントを返す *)
        UnlinkExist;            (* IVA の復帰は TSR 側でします.             *)
        DisableInterrupts;      (* 自分で IVA を復帰する時は必ず I フラグを *)
        CopyIVA := OldCopy;     (* クリアします. 変更後は出来るだけ早く割り *)
        EnableInterrupts;       (* 込みに対応できるように, I フラグを立てる *)
        RETURN SEGMENT( ProgPrefixAddress )|          (* 領域解放に備えます *)
    1:
        RETURN Something;       (* データセグメントに自由にアクセスできます *)
    2:
        InvokeOhter;            (* コードセグメントに自由にアクセスできます *)
    3:
        ...
    END
    RETURN 0
END Selector;

　このように Selector に渡す引数によってレジデントユーティリティ側で好きな
処理ができるのです.

◎ PROCEDURE Free( psp: CARDINAL );

　Free はレジデントユーティリティのメモリを解放する手続きです. 引数は TSR の
PSP (プログラムセグメントプリフィックス) です. PSP の解放に伴い, 環境領域の
解放も合わせて行います. 使い方は次で説明します.

□ 常駐と領域解放

　どのように常駐するのか全く説明していませんでしたが, 常駐するには, モデュール
OtherMSDOS からインポートする手続き:

    PROCEDURE TermStayRes;

　を呼び出します. つまり, 常駐は非常に簡単です.

　逆に常駐を解除して領域を解放する方法はやややっかいです. Icall で制御を移す
エントリーポイント, すなわち Selector 手続きで, 次のような処理を行います.

　まず割り込みベクタアドレスの掃除をしなければなりません. つまり Selector から
UnlinkVsync や UnlinkExist などの手続きを呼び出す必要があります. もしその他の
割り込みをフックしているならば, それも全部復帰します.

　注意してください. Unlink 手続きを呼び出すのはレジデントユーティリティ側です.
ロードプログラム側で Unlink しても意味がありませんし, たぶん暴走します.

　後述の TakeInt 手続きで割り込みをフックした場合, フックの解除はユーザー自身
が行わなければいけません. まずレジデントユーティリティが常駐する前に古い割り
込みベクタアドレスの内容を待避しておきます. その値を Selector 内で復帰するの
です. その際, モデュール IntStub からインポートした手続き:

    DisableInterrupts           割り込みを禁止する
    EnableInterrupts            割り込みを許可する

　を呼び出して割り込みを禁止/許可するのを忘れないでください. 忘れた場合, 運が
悪いと暴走する可能性があります.

　次に領域解放の準備をします. Selector から次の値を返してください.

    PSP セグメント:
        モデュール LOADER からインポートする ProgPrefixAddress のセグメント.

　このようにして獲得したレジデントユーティリティの PSP セグメントを, メモリ
解放手続き Free に渡してやります. 注意してください. PSP を返すのはレジデント
ユーティリティ側ですが, 領域解放はロードプログラム側で行います. TSR が自分の
領域を解放するのはとっても危険だからです.

　注意してください, フックの解除は自分のフックした割り込みに対してのみ行いま
す. これは当り前のように思われますが, 自分がフックしたと思っても, さらに誰かが
同じ割り込みタイプをフックした場合, フックしているのは貴方ではありません. この
ような場合, 領域解放は断念するほかありません.

◎ PROCEDURE GetINDOS(): ADDRESS;

　INDOS フラグのアドレスを得ます. ES:BX が返ります. INDOS フラグとは, DOS
ファンクションが実行中か否かを DOS 自身が管理している変数です. 一種のセマフォ
になっており, 値が 0 であることが DOS ファンクションに入っていない必要条件に
なります. しかし十分条件ではありません.

　DOS 3.1 以降では致命的エラーフラグが INDOS フラグの 1byte 前にあるそうです.

◎ PROCEDURE GetMCB(): ADDRESS;

　一番先頭の MCB のアドレスを得ます. ES:BX が返ります.

□ IR98 の「ま・と・め」

　IR98 を使う実行ファイルは必ずラージモデルでリンクする必要があります.

　LinkVsync は正当な Vsync 割り込みマネージャーではなく, 単にフックを設定する
手続きです. もし (何でも良いのに) Vsync マネージャーが先に常駐していない場合は,
何でも良いから「Vsync 割り込みを使う」と明記されたレジデントユーティリティを
常駐させてください. しかし普通は誰かがフックしていると思います.

　LinkVsync で設定した proc は自動的に Vsync によって割り込まれます.

　LinkBG で設定した proc は自動的に int 28h によって割り込まれます.

　LinkExist で設定した proc は, ユーザー自身が, まず ETYPE を割り出してエン
トリーポイントを獲得し, そのエントリーポイントを Icall 手続きに渡すことで
呼び出します. LinkExit を発行するのはレジデントユーティリティ, Icall を発行
するのはロードプログラム.

　Link 手続きは 1 つのロードプログラムにつき各々 1 個づつの割り込み手続きしか
設定できません. 2 個以上を設定しないで下さい.

　Link 手続きで設定する proc の中では, 自分がフックしている割り込みタイプを
割り出さないでください. 手続き自体が再入可能でも, フック中の手続きには再入され
ない設定をしています. 割り出した場合は自分を飛び越して残りのリンクに制御が
移ります.

　Link 手続きで設定する proc は, なるべく定義モデュールで定義して下さい.
proc の属する定義モデュールで定義するか, あるいは別モデュールからインポート
します. 絶対という訳ではありませんが, これを守らないと効率が落ちます.

　Link 手続きを発行すると, 対応する NewExist, NewVsync, NewBG に新しい IVA の
内容が格納されます. フックを解除する場合は, 現在もその割り込みを自分がフックし
ているのかどうか確認してください. 自分がフックした後に誰かがフックしているかも
知れません.

　レジデントユーティリティを作らない場合で割り込みをフックした場合は, 必ず
Unlink 手続きを呼ばなければなりません. Unlink 手続きでは割り込みベクタアドレス
の掃除をしています.

　レジデントユーティリティの常駐手続はモデュール OtherMSDOS からインポートした
TermStayRes です. スタックは少なめにリンクしましょう. しかし soff の設定を忘れ
て小さくしすぎないように!

□ TakeInt について (TakeInt は FTL MODULA-2 のライブラリ. IR98 とは関係ない)

　Vsync や BG, Exist 以外の割り込みをフックする場合は, モデュール TakeInt を
利用してください. 多少のオーバーヘッドはありますが, 総て MODULA-2 レベルで
記述することができます. TakeInt の原理は IntStub に割り込みハンドラの原形が
あり, それをワークエリアにコピーして引数を埋め込み, 完全な割り込みハンドラを
作ります. つまり割り込みハンドラはデータセグメント中に作成されるのです.
割り込みハンドラはスタックを変更した後に実引数をプッシュして, MODULA-2 の
コードへファーコールします.

　TakeInt を使用する上での注意は, 割り込みをリンク (フック) しようとする場合,
余計に 1 個の割り込みを占有すること. このときモデュール TakeInt の FindUnused
が使用されます. ここで正しい値を返すために, 同様に変数 Map をインポートして
適切な値を設定してください. 普通は次のように設定しておけば十分だと思います.

    FROM TakeInt IMPORT
        TakeInt, Map, IntMap;
    
    ...
    
    Map := IntMap { 40h..5fh };

　これは TakeInt を実行する前に設定する必要があります. 括弧内は「未使用の割り
込みタイプの集合」です. 当然, もっと適切な値を設定することが望まれます. 

　さらに TakeInt を使用する上での注意は, スタックサイズが定数 (200h = たったの
512 バイト) であること. これは重要です. TakeInt で設定した割り込みハンドラから
スタックを大量に消費する手続きを呼び出してはいけません. また, レジスタを使った
交信に制限があります. これはバグです!

　レジスタを使った交信に制限があるのは, 次のようなバグの理由によります.
まず Int に渡される参照呼びだしの Registers と TakeInt で設定する IntProc に
渡される参照呼びだしの Registers は別物です. IntProc はハンドラが設定する
新しいスタックに作られた Registers を操作して, 割り込みハンドラの出口で
総てのレジスタに参照呼びだしの Registers の内容を待避します. ところが, その
後にスタックの復帰をして, その後, 間抜けなことに古い AX と BX を復帰しているの
です!

　しかしただでさえオーバーヘッドが大きいのですから, 高々 2 個のレジスタが
犠牲になったところで, ここは大目にみることにして, AX, BX に値を返さないよう
注意するべきかも知れません. それから FLAGS にも値は返せません.

　ちなみに TakeInt の引数 Size はコード中で使われません. ワークエリアのサイズ
は割り込みハンドラそのものの大きさを確保し, しかもワークエリアはデータセグメン
ト中に静的にアロケートされている必要があります.

　TakeInt からのレジデントユーティリティ内部では IR98 と同様に, コード中を
渡り歩くこともデータセグメントにアクセスすることもできます.

　TakeInt と IR98 を組み合わせることにより, 汎用の割り込みフック手段と, 汎用の
レジデントユーティリティとの交信手段が得られます.

□ 著作権

　IR98 の著作権は私が全権保留中です. しかし使用権はフリーに認めます. このコー
ドを含んだ仕事の成果を私は喜んで受け取ります.

  1994 年 1 月 2 日                       インターネット・メールアドレス:
                                              narita@mt.cs.keio.ac.jp

